diff --git third_party/blink/renderer/core/paint/background_image_geometry.cc third_party/blink/renderer/core/paint/background_image_geometry.cc
index c3aad44662720..1dc05f968c8b7 100644
--- third_party/blink/renderer/core/paint/background_image_geometry.cc
+++ third_party/blink/renderer/core/paint/background_image_geometry.cc
@@ -13,14 +13,12 @@
 #include "third_party/blink/renderer/core/layout/ng/ng_fragmentation_utils.h"
 #include "third_party/blink/renderer/core/layout/ng/ng_physical_box_fragment.h"
 #include "third_party/blink/renderer/core/layout/ng/table/layout_ng_table_cell.h"
-#include "third_party/blink/renderer/core/paint/paint_info.h"
 #include "third_party/blink/renderer/core/paint/paint_layer.h"
 #include "third_party/blink/renderer/core/paint/paint_layer_scrollable_area.h"
 #include "third_party/blink/renderer/core/paint/rounded_border_geometry.h"
 #include "third_party/blink/renderer/core/style/border_edge.h"
 #include "third_party/blink/renderer/platform/geometry/layout_rect.h"
 #include "third_party/blink/renderer/platform/geometry/layout_unit.h"
-#include "third_party/blink/renderer/platform/graphics/paint/geometry_mapper.h"
 #include "third_party/blink/renderer/platform/graphics/paint/paint_controller.h"
 
 namespace blink {
@@ -54,6 +52,25 @@ LayoutUnit ComputeTilePhase(LayoutUnit position, LayoutUnit tile_extent) {
                      : LayoutUnit();
 }
 
+PhysicalOffset AccumulatedScrollOffsetForFixedBackground(
+    const LayoutBoxModelObject& object,
+    const LayoutBoxModelObject* container) {
+  PhysicalOffset result;
+  if (&object == container)
+    return result;
+
+  LayoutObject::AncestorSkipInfo skip_info(container);
+  for (const LayoutBlock* block = object.ContainingBlock(&skip_info);
+       block && !skip_info.AncestorSkipped();
+       block = block->ContainingBlock(&skip_info)) {
+    if (block->IsScrollContainer())
+      result += block->ScrolledContentOffset();
+    if (block == container)
+      break;
+  }
+  return result;
+}
+
 }  // anonymous namespace
 
 bool NeedsFullSizeDestination(const FillLayer& fill_layer) {
@@ -212,7 +229,6 @@ void BackgroundImageGeometry::SetSpaceY(LayoutUnit space,
 
 void BackgroundImageGeometry::UseFixedAttachment(
     const PhysicalOffset& attachment_point) {
-  DCHECK(has_background_fixed_to_viewport_);
   PhysicalOffset fixed_adjustment =
       attachment_point - unsnapped_dest_rect_.offset;
   fixed_adjustment.ClampNegativeToZero();
@@ -312,33 +328,58 @@ PhysicalSize BackgroundImageGeometry::GetBackgroundObjectDimensions(
 }
 
 bool BackgroundImageGeometry::ShouldUseFixedAttachment(
-    const FillLayer& fill_layer) const {
-  // Only backgrounds fixed to viewport should be treated as fixed attachment.
-  // See comments in the private constructor.
-  return has_background_fixed_to_viewport_ &&
-         // Solid color background should use default attachment.
-         fill_layer.GetImage() &&
+    const FillLayer& fill_layer) {
+  // Solid color background should use default attachment.
+  return fill_layer.GetImage() &&
          fill_layer.Attachment() == EFillAttachment::kFixed;
 }
 
 namespace {
 
-PhysicalRect FixedAttachmentPositioningArea(const PaintInfo& paint_info,
-                                            const LayoutBoxModelObject& obj) {
-  DCHECK(obj.View());
-  gfx::PointF viewport_origin_in_local_space =
-      GeometryMapper::SourceToDestinationProjection(
-          obj.View()->FirstFragment().LocalBorderBoxProperties().Transform(),
-          paint_info.context.GetPaintController()
-              .CurrentPaintChunkProperties()
-              .Transform())
-          .MapPoint(gfx::PointF());
-  DCHECK(obj.GetFrameView());
-  const ScrollableArea* layout_viewport = obj.GetFrameView()->LayoutViewport();
+PhysicalRect FixedAttachmentPositioningArea(
+    const LayoutBoxModelObject& obj,
+    const LayoutBoxModelObject* container) {
+  // TODO(crbug.com/667006): We should consider ancestor with transform as the
+  // fixed background container, instead of always the viewport.
+  const LocalFrameView* frame_view = obj.GetFrameView();
+  if (!frame_view)
+    return PhysicalRect();
+
+  const ScrollableArea* layout_viewport = frame_view->LayoutViewport();
   DCHECK(layout_viewport);
-  return PhysicalRect(
-      PhysicalOffset::FromPointFRound(viewport_origin_in_local_space),
-      PhysicalSize(layout_viewport->VisibleContentRect().size()));
+
+  PhysicalRect rect(PhysicalOffset(),
+                    PhysicalSize(layout_viewport->VisibleContentRect().size()));
+
+  if (const auto* layout_view = DynamicTo<LayoutView>(obj)) {
+    if (!(layout_view->GetBackgroundPaintLocation() &
+          kBackgroundPaintInContentsSpace))
+      return rect;
+    // The LayoutView is the only object that can paint a fixed background into
+    // its scrolling contents layer, so it gets a special adjustment here.
+    rect.offset = layout_view->ScrolledContentOffset();
+  }
+
+  rect.Move(AccumulatedScrollOffsetForFixedBackground(obj, container));
+
+  if (!container)
+    return rect;
+
+  rect.Move(
+      -container->LocalToAbsolutePoint(PhysicalOffset(), kIgnoreTransforms));
+
+  // By now we have converted the viewport rect to the border box space of
+  // |container|, however |container| does not necessarily create a paint
+  // offset translation node, thus its paint offset must be added to convert
+  // the rect to the space of the transform node.
+  // TODO(trchen): This function does only one simple thing -- mapping the
+  // viewport rect from frame space to whatever space the current paint
+  // context uses. However we can't always invoke geometry mapper because
+  // there are at least one caller uses this before PrePaint phase.
+  DCHECK_GE(container->GetDocument().Lifecycle().GetState(),
+            DocumentLifecycle::kPrePaintClean);
+  rect.Move(container->FirstFragment().PaintOffset());
+  return rect;
 }
 
 }  // Anonymous namespace
@@ -346,10 +387,7 @@ PhysicalRect FixedAttachmentPositioningArea(const PaintInfo& paint_info,
 BackgroundImageGeometry::BackgroundImageGeometry(
     const LayoutView& view,
     const PhysicalOffset& element_positioning_area_offset)
-    : box_(&view), positioning_box_(&view.RootBox()) {
-  has_background_fixed_to_viewport_ =
-      view.StyleRef().HasFixedAttachmentBackgroundImage();
-  painting_view_ = true;
+    : box_(&view), positioning_box_(&view.RootBox()), painting_view_(true) {
   // The background of the box generated by the root element covers the
   // entire canvas and will be painted by the view object, but the we should
   // still use the root element box for positioning.
@@ -360,17 +398,19 @@ BackgroundImageGeometry::BackgroundImageGeometry(
 
 BackgroundImageGeometry::BackgroundImageGeometry(
     const LayoutBoxModelObject& obj)
-    : BackgroundImageGeometry(&obj, &obj) {}
+    : box_(&obj), positioning_box_(&obj) {
+  // Specialized constructor should be used for LayoutView.
+  DCHECK(!IsA<LayoutView>(obj));
+}
 
 BackgroundImageGeometry::BackgroundImageGeometry(
     const LayoutTableCell& cell,
     const LayoutObject* background_object)
-    : BackgroundImageGeometry(
-          &cell,
-          background_object && !background_object->IsTableCell()
-              ? &To<LayoutBoxModelObject>(*background_object)
-              : &cell) {
-  painting_table_cell_ = true;
+    : box_(&cell),
+      positioning_box_(background_object && !background_object->IsTableCell()
+                           ? &To<LayoutBoxModelObject>(*background_object)
+                           : &cell),
+      painting_table_cell_(true) {
   cell_using_container_background_ =
       background_object && !background_object->IsTableCell();
   if (cell_using_container_background_) {
@@ -386,8 +426,7 @@ BackgroundImageGeometry::BackgroundImageGeometry(const LayoutNGTableCell& cell,
                                                  PhysicalOffset cell_offset,
                                                  const LayoutBox& table_part,
                                                  PhysicalSize table_part_size)
-    : BackgroundImageGeometry(&cell, &table_part) {
-  painting_table_cell_ = true;
+    : box_(&cell), positioning_box_(&table_part), painting_table_cell_(true) {
   cell_using_container_background_ = true;
   element_positioning_area_offset_ = cell_offset;
   positioning_size_override_ = table_part_size;
@@ -395,10 +434,12 @@ BackgroundImageGeometry::BackgroundImageGeometry(const LayoutNGTableCell& cell,
 
 BackgroundImageGeometry::BackgroundImageGeometry(
     const NGPhysicalBoxFragment& fragment)
-    : BackgroundImageGeometry(
-          To<LayoutBoxModelObject>(fragment.GetLayoutObject()),
-          To<LayoutBoxModelObject>(fragment.GetLayoutObject())) {
+    : box_(To<LayoutBoxModelObject>(fragment.GetLayoutObject())),
+      positioning_box_(box_) {
+  DCHECK(box_);
   DCHECK(box_->IsBox());
+  // Specialized constructor should be used for LayoutView.
+  DCHECK(!IsA<LayoutView>(box_));
 
   if (!fragment.IsOnlyForNode()) {
     // The element is block-fragmented. We need to calculate the correct
@@ -410,35 +451,6 @@ BackgroundImageGeometry::BackgroundImageGeometry(
   }
 }
 
-BackgroundImageGeometry::BackgroundImageGeometry(
-    const LayoutBoxModelObject* box,
-    const LayoutBoxModelObject* positioning_box)
-    : box_(box), positioning_box_(positioning_box) {
-  // Specialized constructor should be used for LayoutView.
-  DCHECK(!IsA<LayoutView>(box));
-  DCHECK(box);
-  DCHECK(positioning_box);
-  if (positioning_box->StyleRef().HasFixedAttachmentBackgroundImage()) {
-    has_background_fixed_to_viewport_ = true;
-    // https://www.w3.org/TR/css-transforms-1/#transform-rendering
-    // Fixed backgrounds on the root element are affected by any transform
-    // specified for that element. For all other elements that are effected
-    // by a transform, a value of fixed for the background-attachment property
-    // is treated as if it had a value of scroll.
-    for (const PaintLayer* layer = box->EnclosingLayer();
-         layer && !layer->IsRootLayer(); layer = layer->Parent()) {
-      // Check LayoutObject::HasTransformRelatedProperty() first to exclude
-      // non-applicable transforms and will-change: transform.
-      if (layer->GetLayoutObject().HasTransformRelatedProperty() &&
-          (layer->Transform() ||
-           layer->GetLayoutObject().StyleRef().HasWillChangeTransformHint())) {
-        has_background_fixed_to_viewport_ = false;
-        break;
-      }
-    }
-  }
-}
-
 void BackgroundImageGeometry::ComputeDestRectAdjustments(
     const FillLayer& fill_layer,
     const PhysicalRect& unsnapped_positioning_area,
@@ -592,7 +604,8 @@ void BackgroundImageGeometry::ComputePositioningAreaAdjustments(
 }
 
 void BackgroundImageGeometry::ComputePositioningArea(
-    const PaintInfo& paint_info,
+    const LayoutBoxModelObject* container,
+    PaintPhase paint_phase,
     const FillLayer& fill_layer,
     const PhysicalRect& paint_rect,
     PhysicalRect& unsnapped_positioning_area,
@@ -601,8 +614,9 @@ void BackgroundImageGeometry::ComputePositioningArea(
     PhysicalOffset& snapped_box_offset) {
   if (ShouldUseFixedAttachment(fill_layer)) {
     // No snapping for fixed attachment.
+    SetHasNonLocalGeometry();
     unsnapped_positioning_area =
-        FixedAttachmentPositioningArea(paint_info, *box_);
+        FixedAttachmentPositioningArea(*box_, container);
     unsnapped_dest_rect_ = snapped_dest_rect_ = snapped_positioning_area =
         unsnapped_positioning_area;
   } else {
@@ -637,7 +651,7 @@ void BackgroundImageGeometry::ComputePositioningArea(
     // * We are painting a block-fragmented box.
     // * There is a border image, because it may not be opaque or may be outset.
     bool disallow_border_derived_adjustment =
-        !ShouldPaintSelfBlockBackground(paint_info.phase) ||
+        !ShouldPaintSelfBlockBackground(paint_phase) ||
         fill_layer.Composite() != CompositeOperator::kCompositeSourceOver ||
         painting_view_ || painting_table_cell_ || box_has_multiple_fragments_ ||
         positioning_box_->StyleRef().BorderImage().GetImage() ||
@@ -800,12 +814,10 @@ void BackgroundImageGeometry::CalculateFillTileSize(
   return;
 }
 
-void BackgroundImageGeometry::Calculate(const PaintInfo& paint_info,
+void BackgroundImageGeometry::Calculate(const LayoutBoxModelObject* container,
+                                        PaintPhase paint_phase,
                                         const FillLayer& fill_layer,
                                         const PhysicalRect& paint_rect) {
-  DCHECK_GE(box_->GetDocument().Lifecycle().GetState(),
-            DocumentLifecycle::kPrePaintClean);
-
   // Unsnapped positioning area is used to derive quantities
   // that reference source image maps and define non-integer values, such
   // as phase and position.
@@ -821,7 +833,7 @@ void BackgroundImageGeometry::Calculate(const PaintInfo& paint_info,
   PhysicalOffset snapped_box_offset;
 
   // This method also sets the destination rects.
-  ComputePositioningArea(paint_info, fill_layer, paint_rect,
+  ComputePositioningArea(container, paint_phase, fill_layer, paint_rect,
                          unsnapped_positioning_area, snapped_positioning_area,
                          unsnapped_box_offset, snapped_box_offset);
 
diff --git third_party/blink/web_tests/compositing/backgrounds/fixed-background-on-descendant.html third_party/blink/web_tests/compositing/backgrounds/fixed-background-on-descendant.html
index 3fe07e2a4c6bd..9223c24392a7f 100644
--- third_party/blink/web_tests/compositing/backgrounds/fixed-background-on-descendant.html
+++ third_party/blink/web_tests/compositing/backgrounds/fixed-background-on-descendant.html
@@ -32,7 +32,7 @@
     }
 
     .composited {
-        will-change: opacity;
+        will-change: transform;
     }
 </style>
 <script>
diff --git third_party/blink/web_tests/compositing/backgrounds/fixed-backgrounds.html third_party/blink/web_tests/compositing/backgrounds/fixed-backgrounds.html
index 5d1153dbc2573..02689bea7f4a8 100644
--- third_party/blink/web_tests/compositing/backgrounds/fixed-backgrounds.html
+++ third_party/blink/web_tests/compositing/backgrounds/fixed-backgrounds.html
@@ -22,7 +22,7 @@
     }
 
     .composited {
-        will-change: opacity;
+        will-change: transform;
     }
 </style>
 <script>
diff --git third_party/blink/web_tests/external/wpt/css/cssom-view/add-background-attachment-fixed-during-smooth-scroll.html third_party/blink/web_tests/external/wpt/css/cssom-view/add-background-attachment-fixed-during-smooth-scroll.html
index 6600c0e0555ce..a031b3715a34b 100644
--- third_party/blink/web_tests/external/wpt/css/cssom-view/add-background-attachment-fixed-during-smooth-scroll.html
+++ third_party/blink/web_tests/external/wpt/css/cssom-view/add-background-attachment-fixed-during-smooth-scroll.html
@@ -11,7 +11,7 @@
   height: 200px;
   overflow: scroll;
   background: linear-gradient(green, blue);
-  will-change: scroll-position;
+  will-change: transform;
 }
 #content {
   width: 7500px;
